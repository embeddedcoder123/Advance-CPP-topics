# C++14

## Overview
Many of these descriptions and examples are taken from various resources (see [Acknowledgements](#acknowledgements) section) and summarized in my own words.

C++14 includes the following new language features:
- [binary literals](#binary-literals)
- [generic lambda expressions](#generic-lambda-expressions)
- [lambda capture initializers](#lambda-capture-initializers)
- [return type deduction](#return-type-deduction)
- [decltype(auto)](#decltypeauto)
- [relaxing constraints on constexpr functions](#relaxing-constraints-on-constexpr-functions)
- [variable templates](#variable-templates)
- [\[\[deprecated\]\] attribute](#deprecated-attribute)

C++14 includes the following new library features:
- [user-defined literals for standard library types](#user-defined-literals-for-standard-library-types)
- [compile-time integer sequences](#compile-time-integer-sequences)
- [std::make_unique](#stdmake_unique)

## C++14 Language Features

### Binary literals
Binary literals provide a convenient way to represent a base-2 number.
It is possible to separate digits with `'`.
```c++
0b110 // == 6
0b1111'1111 // == 255
```
### Return type deduction
In C++14, functions can automatically deduce their return type, just like lambdas could in C++11.
```c++
// Deduce return type as `int`.
auto f(int i) {
 return i;
}
/*
No need to specify -> decltype(...) or write the return type manually unless you want to.
*/
```

```c++
template <typename T>
auto& f(T& t) {
  return t;
}
```
**What’s Still Not Allowed**
> C++14 does not allow auto as the return type in recursive functions without an explicit return type in certain cases: C++14 does not allow auto as the return type in recursive functions without an explicit return type in certain cases:
ckeck below example
```c++
// May not compile without a forward declaration or trailing return type
//You may need to use a trailing return type or decltype if deduction can’t resolve correctly.
auto factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```


### decltype(auto)
**auto makes a copy, while decltype(auto) can keep the reference.**
```c++
const int x = 0;
auto x1 = x; // int
decltype(auto) x2 = x; // const int

int y = 0;
int& y1 = y;
auto y2 = y1; // int
decltype(auto) y3 = y1; // int&

int&& z = 0;
auto z1 = std::move(z); // int
decltype(auto) z2 = std::move(z); // int&&
```

```c++
// Note: Especially useful for generic code!


// Return type is `int`.
auto f(const int& i) {
 return i;
}

// Return type is `const int&`.
decltype(auto) g(const int& i) {
 return i;
}
int x = 123;
static_assert(std::is_same<const int&, decltype(f(x))>::value == 0);
static_assert(std::is_same<int, decltype(f(x))>::value == 1);
static_assert(std::is_same<const int&, decltype(g(x))>::value == 1);
```

See also: [`decltype (C++11)`](README.md#decltype).

### Relaxing constraints on constexpr functions
**C++14 relaxed the rules**
1. Multiple statements
2. Local variables
3. Conditionals and loops

**1 Multiple statements**
Invalid in C++11 — multiple statements not allowed
```c++
constexpr int square(int x) {
    int result = x * x;  // Error in C++11: not allowed
    return result;
}
//This will cause a compile-time error in C++11, because declaring and assigning a variable (int result = x * x) is not allowed in constexpr functions in C++11.
//But this is allowd in C++14
```
**2.Local Variables Allowed**
- C++11: You could not declare local variables inside constexpr functions.
- C++14: You can declare and initialize local variables (including mutable ones, if the function is a member function).
```cpp
constexpr int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i)
        result *= i;
    return result;
}
```
**3. Loops and Conditionals**
- C++11: No for, while, if, etc. were allowed.
- C++14: You can use if, switch, for, while, do-while, etc.
```cpp
constexpr int sum_to_n(int n) {
    int sum = 0;
    for (int i = 1; i <= n; ++i)
        sum += i;
    return sum;
}
```
**4. More Flexibility with Return Statements**
- You can now use early returns, which was not allowed in C++11.
```cpp
constexpr bool is_even(int x) {
    if (x % 2 == 0)
        return true;
    else
        return false;
}
```
**Limitations Still Present in C++14**
Even with these improvements, there are still rules:
- constexpr must be deterministic and side-effect-free) means it can not change global variable and IO operation
- Dynamic memory allocation (new, delete) is still not allowed.
- Non-constexpr function can not be called in a constexpr function.
### Variable templates
C++14 allows variables to be templated:

```c++
template<class T>
constexpr T pi = T(3.1415926535897932385);
template<class T>
constexpr T e  = T(2.7182818284590452353);
```

### [[deprecated]] attribute
C++14 introduces the `[[deprecated]]` attribute to indicate that they should not be used in new code, and compilers can warn when they are
```c++
[[deprecated]]
void old_method();
[[deprecated("Use new_method instead")]]
void legacy_method();
```

## C++14 Library Features

### User-defined literals for standard library types
New user-defined literals for standard library types, including new built-in literals for `chrono` and `basic_string`. These can be `constexpr` meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.
```c++
using namespace std::chrono_literals;
auto day = 24h;
day.count(); // == 24
std::chrono::duration_cast<std::chrono::minutes>(day).count(); // == 1440
```

### Compile-time integer sequences
The class template `std::integer_sequence` represents a compile-time sequence of integers. There are a few helpers built on top:
* `std::make_integer_sequence<T, N>` - creates a sequence of `0, ..., N - 1` with type `T`.
* `std::index_sequence_for<T...>` - converts a template parameter pack into an integer sequence.

Convert an array into a tuple:
```c++
template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {
  return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
  return a2t_impl(a, Indices());
}
```

### std::make_unique
`std::make_unique` is the recommended way to create instances of `std::unique_ptr`s due to the following reasons:
* Avoid having to use the `new` operator.
* Prevents code repetition when specifying the underlying type the pointer shall hold.
* Most importantly, it provides exception-safety. Suppose we were calling a function `foo` like so:
```c++
foo(std::unique_ptr<T>{new T{}}, function_that_throws(), std::unique_ptr<T>{new T{}});
```
The compiler is free to call `new T{}`, then `function_that_throws()`, and so on... Since we have allocated data on the heap in the first construction of a `T`, we have introduced a leak here. With `std::make_unique`, we are given exception-safety:
```c++
foo(std::make_unique<T>(), function_that_throws(), std::make_unique<T>());
```

See the section on [smart pointers (C++11)](README.md#smart-pointers) for more information on `std::unique_ptr` and `std::shared_ptr`.

## Acknowledgements
* [cppreference](http://en.cppreference.com/w/cpp) - especially useful for finding examples and documentation of new library features.
* [C++ Rvalue References Explained](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.
* [clang](http://clang.llvm.org/cxx_status.html) and [gcc](https://gcc.gnu.org/projects/cxx-status.html)'s standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers' Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - highly recommended book!
* [Jason Turner's C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - nice collection of C++-related videos.
* [What can I do with a moved-from object?](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [What are some uses of decltype(auto)?](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)
* And many more SO posts I'm forgetting...

## Author
**Haresh Panchal**
