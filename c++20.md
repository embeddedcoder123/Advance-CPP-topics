# C++20

## Overview
Many of these descriptions and examples are taken from various resources (see [Acknowledgements](#acknowledgements) section) and summarized in my own words.

C++20 includes the following new language features:
- [C++20](#c20)
  - [Overview](#overview)
  - [C++20 Language Features](#c20-language-features)
    - [Coroutines](#coroutines)
      - [Coroutine handles](#coroutine-handles)
      - [The coroutine return object](#the-coroutine-return-object)
      - [The promise object](#the-promise-object)
      - [The co\_return operator](#the-co_return-operator)
      - [The co\_return operator](#the-co_return-operator-1)
      - [Generic generator example](#generic-generator-example)
        - [Why use a Generator?](#why-use-a-generator)
        - [Real Code Example: Even Number Generator](#real-code-example-even-number-generator)
    - [Concepts](#concepts)
        - [Why Are Concepts Useful?](#why-are-concepts-useful)
        - [Without concepts:](#without-concepts)
        - [With Concepts:](#with-concepts)
          - [Example 1: Concept to check if + works](#example-1-concept-to-check-if--works)
          - [Example 2: Built-in Concept — Only integers allowed](#example-2-built-in-concept--only-integers-allowed)
          - [Example 3: Use concept with auto (shortcut)](#example-3-use-concept-with-auto-shortcut)
          - [Example 4: Custom Concept — Has size() method](#example-4-custom-concept--has-size-method)
          - [Example 5: Multiple Concepts Together](#example-5-multiple-concepts-together)
    - [Three-way comparison](#three-way-comparison)
    - [Designated initializers](#designated-initializers)
    - [Template syntax for lambdas](#template-syntax-for-lambdas)
    - [Range-based for loop with initializer](#range-based-for-loop-with-initializer)
    - [\[\[likely\]\] and \[\[unlikely\]\] attributes](#likely-and-unlikely-attributes)
    - [Deprecate implicit capture of this](#deprecate-implicit-capture-of-this)
    - [Class types in non-type template parameters](#class-types-in-non-type-template-parameters)
    - [constexpr virtual functions](#constexpr-virtual-functions)
    - [explicit(bool)](#explicitbool)
    - [Immediate functions](#immediate-functions)
    - [using enum](#using-enum)
    - [Lambda capture of parameter pack](#lambda-capture-of-parameter-pack)
    - [char8\_t](#char8_t)
    - [constinit](#constinit)
    - [\_\_VA\_OPT\_\_](#__va_opt__)
  - [C++20 Library Features](#c20-library-features)
    - [Concepts library](#concepts-library)
    - [Formatting library](#formatting-library)
    - [Synchronized buffered outputstream](#synchronized-buffered-outputstream)
    - [std::span](#stdspan)
    - [Bit operations](#bit-operations)
    - [Math constants](#math-constants)
    - [std::is\_constant\_evaluated](#stdis_constant_evaluated)
    - [std::make\_shared supports arrays](#stdmake_shared-supports-arrays)
    - [starts\_with and ends\_with on strings](#starts_with-and-ends_with-on-strings)
    - [Check if associative container has element](#check-if-associative-container-has-element)
    - [std::bit\_cast](#stdbit_cast)
    - [std::midpoint](#stdmidpoint)
    - [std::to\_array](#stdto_array)
    - [std::bind\_front](#stdbind_front)
    - [Uniform container erasure](#uniform-container-erasure)
    - [Three-way comparison helpers](#three-way-comparison-helpers)
    - [std::lexicographical\_compare\_three\_way](#stdlexicographical_compare_three_way)
  - [Acknowledgements](#acknowledgements)
  - [Author](#author)
  - [Content Contributors](#content-contributors)
  - [License](#license)

C++20 includes the following new library features:
- [C++20](#c20)
  - [Overview](#overview)
  - [C++20 Language Features](#c20-language-features)
    - [Coroutines](#coroutines)
      - [Coroutine handles](#coroutine-handles)
      - [The coroutine return object](#the-coroutine-return-object)
      - [The promise object](#the-promise-object)
      - [The co\_return operator](#the-co_return-operator)
      - [The co\_return operator](#the-co_return-operator-1)
      - [Generic generator example](#generic-generator-example)
        - [Why use a Generator?](#why-use-a-generator)
        - [Real Code Example: Even Number Generator](#real-code-example-even-number-generator)
    - [Concepts](#concepts)
        - [Why Are Concepts Useful?](#why-are-concepts-useful)
        - [Without concepts:](#without-concepts)
        - [With Concepts:](#with-concepts)
          - [Example 1: Concept to check if + works](#example-1-concept-to-check-if--works)
          - [Example 2: Built-in Concept — Only integers allowed](#example-2-built-in-concept--only-integers-allowed)
          - [Example 3: Use concept with auto (shortcut)](#example-3-use-concept-with-auto-shortcut)
          - [Example 4: Custom Concept — Has size() method](#example-4-custom-concept--has-size-method)
          - [Example 5: Multiple Concepts Together](#example-5-multiple-concepts-together)
    - [Three-way comparison](#three-way-comparison)
    - [Designated initializers](#designated-initializers)
    - [Template syntax for lambdas](#template-syntax-for-lambdas)
    - [Range-based for loop with initializer](#range-based-for-loop-with-initializer)
    - [\[\[likely\]\] and \[\[unlikely\]\] attributes](#likely-and-unlikely-attributes)
    - [Deprecate implicit capture of this](#deprecate-implicit-capture-of-this)
    - [Class types in non-type template parameters](#class-types-in-non-type-template-parameters)
    - [constexpr virtual functions](#constexpr-virtual-functions)
    - [explicit(bool)](#explicitbool)
    - [Immediate functions](#immediate-functions)
    - [using enum](#using-enum)
    - [Lambda capture of parameter pack](#lambda-capture-of-parameter-pack)
    - [char8\_t](#char8_t)
    - [constinit](#constinit)
    - [\_\_VA\_OPT\_\_](#__va_opt__)
  - [C++20 Library Features](#c20-library-features)
    - [Concepts library](#concepts-library)
    - [Formatting library](#formatting-library)
    - [Synchronized buffered outputstream](#synchronized-buffered-outputstream)
    - [std::span](#stdspan)
    - [Bit operations](#bit-operations)
    - [Math constants](#math-constants)
    - [std::is\_constant\_evaluated](#stdis_constant_evaluated)
    - [std::make\_shared supports arrays](#stdmake_shared-supports-arrays)
    - [starts\_with and ends\_with on strings](#starts_with-and-ends_with-on-strings)
    - [Check if associative container has element](#check-if-associative-container-has-element)
    - [std::bit\_cast](#stdbit_cast)
    - [std::midpoint](#stdmidpoint)
    - [std::to\_array](#stdto_array)
    - [std::bind\_front](#stdbind_front)
    - [Uniform container erasure](#uniform-container-erasure)
    - [Three-way comparison helpers](#three-way-comparison-helpers)
    - [std::lexicographical\_compare\_three\_way](#stdlexicographical_compare_three_way)
  - [Acknowledgements](#acknowledgements)
  - [Author](#author)
  - [Content Contributors](#content-contributors)
  - [License](#license)

## C++20 Language Features

### Coroutines
[_Coroutines source Link_](https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html)
> **Note:** Coroutines in C++20 are special functions that can pause and resume their execution. They don’t share a stack, so they can jump between each other easily.

However, using them in C++ is a bit messy:
- The core feature (like co_await) is nice, but it's buried under a lot of boilerplate code you have to write yourself.
- The C++ standard library doesn’t provide the support types you need, so you have to build that "support structure" (called the promise, awaiter, etc.) yourself.
   >❗ **Note on Confusion:**
Terms like promise and future used in coroutine discussions do not refer to std::promise or std::future from <future>. That’s a common source of confusion.

✅**What co_await Does (Simply)**
When you write co_await a; in a coroutine:
- The coroutine’s state (local variables, etc.) is saved on the heap.
- A resumer function is created to continue the coroutine later.
- a is asked to handle the pause and resume logic.
- The coroutine stops here and will only continue if a decides to call the resumer.
  
It’s like giving a the power to resume the function when it's ready.

📚 **When to Use Coroutines**
- Implementing asynchronous I/O (like file or network I/O).
- Creating lazy sequences (generators).
- Replacing complex state machines or callback hell.
- Writing cleaner, more linear async logic.

**In C++20, a coroutine must:**
1. Return a coroutine-compatible type (not just any type).
>    In C++20, a coroutine-compatible type is a special return type (like std::generator or a custom type with a promise_type) that integrates with the coroutine system, enabling co_await, co_yield, or co_return to work correctly.
2. Use at least one of the coroutine keywords:
> - co_await – suspends until an awaitable completes.
> - co_yield – yields a value (used in generators).
> - co_return – returns a final value or signals completion.

**Compiling code using coroutines**
>g++ -fcoroutines -std=c++20
Clang’s support is less far along. You need to install llvm libc++ and compile with:
clang++ -std=c++20 -stdlib=libc++ -fcoroutines-ts

#### Coroutine handles
> - std::coroutine_handle<> is the type used to manage coroutine state.
> - It behaves like a C pointer: easy to copy but must be manually destroyed with destroy() to avoid memory leaks.
> - If you use a handle after it’s destroyed, it leads to undefined behavior.
> - The handle remains valid throughout the coroutine’s life.
> - When you write co_await a, the compiler passes the coroutine handle to a.await_suspend(handle).
> - The object a must implement await_ready(), await_suspend(), and await_resume() — making it an “awaiter.”

Now let’s look at a complete program that uses co_await. For now, ignore the ReturnObject type—it’s just part of the garbage we have to get through to access co_await.
```c++
#include <concepts>
#include <coroutine>
#include <exception>
#include <iostream>

struct ReturnObject { // This is return type, callable function should return
  struct promise_type {
    ReturnObject get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
  };
};

struct Awaiter {
  std::coroutine_handle<> *hp_;
  constexpr bool await_ready() const noexcept { return false; }
  void await_suspend(std::coroutine_handle<> h) { *hp_ = h; }
  constexpr void await_resume() const noexcept {}
};

ReturnObject counter(std::coroutine_handle<> *continuation_out)
{
  Awaiter a{continuation_out};
  for (unsigned i = 0;; ++i) {
    co_await a;
    std::cout << "counter: " << i << std::endl;
  }
}

int main ()
{
  std::coroutine_handle<> h;
  counter(&h);
  for (int i = 0; i < 3; ++i) {
    std::cout << "In main function\n";
    h();
  }
  h.destroy();
  return 0;
}
/*
In main function
counter: 0
In main function
counter: 1
In main1 function
counter: 2
*/

```
**In C++ coroutines, an awaiter needs three functions:**
- **await_ready**: Tells if the coroutine should suspend or keep going. If it returns true, no suspension happens.
- **await_suspend**: Runs if suspension is needed. It handles how the coroutine pauses.
- **await_resume**: Runs when the coroutine resumes. It gives the result of the co_await.

**C++ provides two built-in awaiters:**
- **std::suspend_always**: Always suspends the coroutine.
- **std::suspend_never**: Never suspends it.


#### The coroutine return object
**1. Coroutines return a special type, not just a simple value.**
> - This return type must have a nested promise_type class.
> - The compiler uses promise_type to manage the coroutine’s internal state.
> 
**2. Inside promise_type, the method get_return_object() tells the compiler what to return from the coroutine.**
> - We want to return a ReturnObject2 that holds a coroutine handle.

1. To get the handle from inside get_return_object(), we use:
    ```c++
    std::coroutine_handle<promise_type>::from_promise(*this)
    ```

Below program illustrate
```c++
#include <coroutine>
#include <iostream>

struct ReturnObject2 {
  struct promise_type {
    // Called when the coroutine starts to set up the return object
    ReturnObject2 get_return_object() {
      return {
        .h_ = std::coroutine_handle<promise_type>::from_promise(*this)
      };
    }

    // Coroutine starts immediately (no suspension at the beginning)
    std::suspend_never initial_suspend() { return {}; }

    // Coroutine ends without suspending (immediately done)
    std::suspend_never final_suspend() noexcept { return {}; }

    // What to do if an exception is thrown
    void unhandled_exception() {}

    // No return value for this coroutine
    void return_void() {}
  };

  // Store the coroutine handle
  std::coroutine_handle<promise_type> h_;

  // Allow implicit conversion to generic coroutine_handle<>
  operator std::coroutine_handle<>() const { return h_; }
};

ReturnObject2 counter2() {
  for (unsigned i = 0;; ++i) {
    co_await std::suspend_always{}; // Suspend after each loop iteration
    std::cout << "counter2: " << i << std::endl;
  }
}

int main() {
  // Start coroutine and get the handle
  std::coroutine_handle<> h = counter2();

  // Resume the coroutine 3 times
  for (int i = 0; i < 3; ++i) {
    std::cout << "In main function\n";
    h(); // Resume coroutine
  }

  // Manually destroy coroutine to avoid memory leak
  h.destroy();

  return 0;
}
/*
In main function
counter2: 0
In main function
counter2: 1
In main function
counter2: 2
*/
```
**Here's a simple and brief explanation:**

> - ReturnObject2 is a special object used to control a coroutine’s lifetime. It stores a coroutine_handle, which is like a pointer to the coroutine’s state.
> - The coroutine function counter2() suspends itself after each number using co_await std::suspend_always{}. This means it pauses and lets the caller decide when to resume it.
> - In main(), we get a handle to the coroutine and call it 3 times. Each call resumes the coroutine, which then prints the next number.
> - The coroutine_handle is just a lightweight pointer, so even though the ReturnObject2 goes out of scope, the handle remains valid.
> - But, because the coroutine allocates memory internally, we must call h.destroy() to free that memory. Otherwise, it causes a memory leak.

#### The promise object
**What’s going on?**
- So far, the coroutine just paused and printed stuff, but didn't send data back to the caller (main function).
- We want the coroutine to send values to main, so main can decide what to do with them.

**How?**
- Every coroutine has a promise object that stores the coroutine’s state.
- We add a variable value_ inside the promise to hold the number the coroutine wants to send.
- To access the promise inside the coroutine, we use a special helper called GetPromise.

- GetPromise is an awaiter that:
    1.  Gives us access to the promise object.
    2.  Does not pause the coroutine when awaited.
- Inside the coroutine (counter3), we write the current number into promise.value_ every loop.
- In main, we get the promise through the coroutine handle, and read the number from promise.value_ and print it.
- We resume the coroutine manually with h().
- When done, we call h.destroy() to clean up memory.
```c++
#include <coroutine>
#include <iostream>

// Awaiter to get promise object inside the coroutine
template<typename PromiseType>
struct GetPromise {
  PromiseType *p_;
  bool await_ready() { return false; } // Will call await_suspend
  bool await_suspend(std::coroutine_handle<PromiseType> h) {
    p_ = &h.promise();   // Save pointer to promise object
    return false;        // Don't suspend coroutine
  }
  PromiseType *await_resume() { return p_; } // Return the promise pointer
};

// Return object holding coroutine handle and promise_type
struct ReturnObject3 {
  struct promise_type {
    unsigned value_;  // Field to pass data from coroutine to main

    ReturnObject3 get_return_object() {
      return ReturnObject3 {
        .h_ = std::coroutine_handle<promise_type>::from_promise(*this)
      };
    }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}
  };

  std::coroutine_handle<promise_type> h_;
  operator std::coroutine_handle<promise_type>() const { return h_; }
};

// Coroutine function that updates promise.value_ and suspends each step
ReturnObject3 counter3() {
  auto pp = co_await GetPromise<ReturnObject3::promise_type>{}; // Get promise

  for (unsigned i = 0;; ++i) {
    pp->value_ = i;                // Update promise value
    co_await std::suspend_always{}; // Suspend coroutine
  }
}

// Main function to resume coroutine and print values from promise
void main3() {
  std::coroutine_handle<ReturnObject3::promise_type> h = counter3();
  ReturnObject3::promise_type &promise = h.promise();

  for (int i = 0; i < 3; ++i) {
    std::cout << "counter3: " << promise.value_ << std::endl;
    h(); // Resume coroutine
  }
  h.destroy(); // Clean up memory
}

int main() {
  main3();
  return 0;
}
/*
counter3: 0
counter3: 1
counter3: 2
*/
```
#### The co_return operator
**What’s going on?**
- co_yield is a special coroutine keyword designed to make it easier to send values from a coroutine back to the caller.
- Instead of manually getting the promise object like before, you just write co_yield value; inside the coroutine.
- Behind the scenes, co_yield e; calls co_await promise.yield_value(e); on the promise object.
- So, if the promise has a method called yield_value, it’s automatically used to handle the yielded value.
- This simplifies the previous approach because the coroutine itself can just yield values directly.

**How the code works:**
- The promise_type has a yield_value method that:
    1. Stores the yielded value inside value_.
    2. Returns std::suspend_always{} to suspend the coroutine after yielding.
- Inside the coroutine (counter4), we just write co_yield i; to send values out.
- In main4, we get the coroutine handle and access the promise’s value_ field.
- Each time we resume the coroutine by calling h(), it produces the next value.
- We print that value in main4.
- Finally, we clean up with h.destroy().
```c++
#include <coroutine>
#include <iostream>

struct ReturnObject4 {
  struct promise_type {
    unsigned value_;

    ReturnObject4 get_return_object() {
      return {
        .h_ = std::coroutine_handle<promise_type>::from_promise(*this)
      };
    }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() {}

    // This is called automatically by co_yield
    std::suspend_always yield_value(unsigned value) {
      value_ = value;       // Store the yielded value
      return {};           // Suspend coroutine after yielding
    }
  };

  std::coroutine_handle<promise_type> h_;
};

ReturnObject4 counter4() {
  for (unsigned i = 0;; ++i)
    co_yield i;    // Yield the current value
}

void main4() {
  auto h = counter4().h_;
  auto &promise = h.promise();

  for (int i = 0; i < 3; ++i) {
    std::cout << "counter4: " << promise.value_ << std::endl;
    h();          // Resume coroutine to get next value
  }
  h.destroy();   // Clean up
}

int main() {
  main4();
  return 0;
}
/*
counter4: 0
counter4: 1
counter4: 2
*/
```
#### The co_return operator
**What’s the idea?**
- So far, the coroutine gave infinite values (kept counting forever).
- But sometimes you want the coroutine to produce a limited number of values and then stop.
- To tell the coroutine is finished, C++ uses co_return.

**How does co_return work?**
- co_return e; calls promise.return_value(e) on the promise object.
- co_return; (or just falling off the end of the function) calls promise.return_void().
- The coroutine is done when handle.done() returns true.
- Important: The promise must have return_void() or return_value() methods if you use co_return, or your code won't compile.
- Also, if your coroutine falls off the end but promise lacks return_void(), it causes undefined behavior (bad stuff like crashes).

**Final suspend**
- When a coroutine ends, it calls final_suspend().
- If final_suspend() returns an awaitable that suspends (like std::suspend_always), the coroutine stays alive (so main can inspect it and clean up).
- If final_suspend() returns std::suspend_never (doesn't suspend), coroutine state is destroyed immediately after finishing.
- Usually, you want to suspend at the end so the main function can safely call destroy() on the coroutine handle.
- If you don't, and main still calls handle after the coroutine is destroyed, you get crashes.
```c++
#include <coroutine>
#include <iostream>

struct ReturnObject5 {
  struct promise_type {
    unsigned value_;

    ~promise_type() {
      std::cout << "promise_type destroyed\n";
    }

    ReturnObject5 get_return_object() {
      return {
        .h_ = std::coroutine_handle<promise_type>::from_promise(*this)
      };
    }

    std::suspend_never initial_suspend() { return {}; }
    std::suspend_always final_suspend() noexcept { return {}; }  // suspend at end

    void unhandled_exception() {}

    std::suspend_always yield_value(unsigned value) {
      value_ = value;
      return {};
    }

    void return_void() {}  // required because we fall off end (no co_return value)
  };

  std::coroutine_handle<promise_type> h_;
};

ReturnObject5 counter5() {
  for (unsigned i = 0; i < 3; ++i)
    co_yield i;

  // falling off end means co_return void
}

void main5() {
  auto h = counter5().h_;
  auto &promise = h.promise();

  while (!h.done()) {       // check if coroutine is finished
    std::cout << "counter5: " << promise.value_ << "\n";
    h();                    // resume coroutine
  }

  h.destroy();              // clean up coroutine state
}

int main() {
  main5();
  return 0;
}
/*
counter5: 0
counter5: 1
counter5: 2
promise_type destroyed
*/
```
**What happens if final_suspend() returns std::suspend_never?**
- Coroutine state is destroyed immediately after finishing.
- But main still tries to use the handle (h.done() and h()).
- This causes undefined behavior like crashes or segmentation faults because the coroutine no longer exists.
#### Generic generator example
> **What is a Generator?**
> A generator is like a special function that can pause and resume while producing a sequence of values one by one.
> You ask for the next value, it gives you one, then pauses until you ask again.

##### Why use a Generator?
**Imagine you want to generate numbers one at a time, for example:**
> * All even numbers.
> * Fibonacci sequence.
> * Reading lines from a file.
> * Generating sensor data.

**Instead of:**
> * Storing everything in memory.
> * Returning a big array or list.
> 
> You can pause after each value and resume when needed — saving memory and processing time. That's what generators help you do!
> 
**Real-World Analogy**
> Think of a YouTube playlist. You don’t download all videos at once. You click "Next" to play one video at a time.
> 
**A generator works similarly:**
> * You get one value.
> * Pause. 
> * Ask for next value.
> * Pause again.

##### Real Code Example: Even Number Generator
**Step 1: The Generator Template (same as before, slightly simplified)**
```c++
#include <coroutine>
#include <iostream>
#include <exception>

template<typename T>
struct Generator {
    struct promise_type {
        T current_value;
        std::exception_ptr exception;

        Generator get_return_object() {
            return Generator{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        void unhandled_exception() {
            exception = std::current_exception(); // Store any exception
        }

        std::suspend_always yield_value(T value) {
            current_value = value;
            return {};
        }

        void return_void() {}
    };

    using handle_type = std::coroutine_handle<promise_type>;
    handle_type coro;

    Generator(handle_type h) : coro(h) {}
    ~Generator() { if (coro) coro.destroy(); }

    bool move_next() {
        coro.resume();
        if (coro.done()) {
            if (coro.promise().exception)
                std::rethrow_exception(coro.promise().exception);
            return false;
        }
        return true;
    }

    T current_value() {
        return coro.promise().current_value;
    }
};

```
**Step 2: The Coroutine Function (Even Number Generator)**
```c++
Generator<int> generate_evens(int max) {
    for (int i = 0; i <= max; i += 2) {
        co_yield i;
    }
}
//This will yield: 0, 2, 4, 6, ..., up to max
```
Step 3: Using It in main
```c++
int main() {
    auto gen = generate_evens(10); // Generate even numbers up to 10

    while (gen.move_next()) {
        std::cout << "Even number: " << gen.current_value() << '\n';
    }
}
/*
Even number: 0
Even number: 2
Even number: 4
Even number: 6
Even number: 8
Even number: 10
*/
```
### Concepts
> _Concepts are rules you can give to template parameters.
> They help make sure that only correct types are passed to templates._
##### Why Are Concepts Useful?
##### Without concepts:
```c++
template<typename T>
T add(T a, T b) {
    return a + b;  // Error if T doesn't support +
}

int main() {
    add("hello", 5);  // ❌ BAD: string + int doesn't work You get a long, ugly compiler error.
}
```
##### With Concepts:
###### Example 1: Concept to check if + works
```c++
#include <iostream>
#include <concepts>

// This is a concept: it checks if type T can be added (+)
template<typename T>
concept Addable = requires(T a, T b) {
    a + b;
};

// Use the concept in a template
template<Addable T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(2, 3) << "\n";        // ✅ OK: int supports +
    std::cout << add(2.5, 1.5) << "\n";    // ✅ OK: double supports +
    // add("Hi", 3);                       // ❌ ERROR: string + int not allowed
}

```
###### Example 2: Built-in Concept — Only integers allowed
```c++
#include <iostream>
#include <concepts>

// Only allow integer values
void printDouble(std::integral auto value) {
    std::cout << value * 2 << "\n";
}

int main() {
    printDouble(5);      // ✅ OK
    // printDouble(3.14);  // ❌ ERROR: 3.14 is not an integer
}

```
###### Example 3: Use concept with auto (shortcut)
See also: [concepts library](#concepts-library).
```c++
//Instead of writing:
template<std::integral T>
void doSomething(T value);

//You can write:
void doSomething(std::integral auto value);

//Both mean the same!
```
######  Example 4: Custom Concept — Has size() method
What if you only want to accept types that have .size()?
Like std::vector, std::string etc.
```c++
#include <iostream>
#include <concepts>
#include <vector>
#include <string>

// Our own concept: checks if type has size()
template<typename T>
concept HasSize = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Use it in a function
template<HasSize T>
void printSize(const T& container) {
    std::cout << "Size: " << container.size() << "\n";
}

int main() {
    std::vector<int> v = {1, 2, 3};
    std::string s = "Hello";

    printSize(v);  // ✅ OK
    printSize(s);  // ✅ OK
    // printSize(5);  // ❌ ERROR: int has no size()
}
```
###### Example 5: Multiple Concepts Together
```c++
#include <concepts>
#include <iostream>

// Accept only values that are both integral and default-initializable
template<typename T>
concept MyConcept = std::integral<T> && std::default_initializable<T>;

template<MyConcept T>
void showDefaultValue() {
    T x{};
    std::cout << "Default value: " << x << "\n";
}

int main() {
    showDefaultValue<int>();  // ✅ OK
    // showDefaultValue<std::string>(); // ❌ ERROR: std::string is not integral
}

```
### Three-way comparison (Spaceship Operator)
Before C++20, when creating your own types (e.g., structs), if you wanted to compare objects, you'd often have to manually define all comparison operators. That’s verbose and error-prone.

With <=>, C++20:
> - Reduces boilerplate code.
> - Enables a single point of definition for all comparisons.
> - Supports total, weak, and partial ordering.

**Basic Syntax**
```c++
auto operator<=>(const T& other) const;
```
- Returns a comparison category type:
    std::strong_ordering, std::weak_ordering, or std::partial_ordering.
- auto can deduce the correct return type.
- Can use = default to auto-generate comparisons.


**⚙ Comparison Category Types**
Category Type | Used For | Allows == | Allows <
--------------|----------|-----------|---------
std::strong_ordering | Most types (e.g. int, char) | ✅ | ✅
std::weak_ordering | Case-insensitive compares | ✅ | ✅
std::partial_ordering | Floating-point with NaN | ✅ | ✅

> _Note: NaN means Not a Number__

**All-in-One Example**
```c++
#include <iostream>
#include <compare>
#include <cmath>

struct Point {
    int x, y;
    auto operator<=>(const Point&) const = default; // auto compare x and y
};

class Box {
    int volume;
public:
    Box(int v) : volume(v) {}
    std::strong_ordering operator<=>(const Box& other) const {
        return volume <=> other.volume;
    }
    bool operator==(const Box& other) const = default; // still needed if not using = default
};

int main() {
    // 🔹 1. Built-in type comparison
    int a = 10, b = 20;
    std::cout << "[int] ";
    if (auto r = a <=> b; r < 0) std::cout << "a < b\n";
    else if (r > 0) std::cout << "a > b\n";
    else std::cout << "a == b\n";

    // 🔹 2. Custom type with = default
    Point p1{1, 2}, p2{1, 3};
    std::cout << "[Point] ";
    if (p1 < p2) std::cout << "p1 < p2\n";
    else if (p1 > p2) std::cout << "p1 > p2\n";
    else std::cout << "p1 == p2\n";

    // 🔹 3. Custom type with manual <=> and strong_ordering
    Box box1(100), box2(200);
    std::cout << "[Box] ";
    if (auto r = box1 <=> box2; r < 0) std::cout << "box1 < box2\n";
    else if (r > 0) std::cout << "box1 > box2\n";
    else std::cout << "box1 == box2\n";

    // 🔹 4. Floating point comparison with NaN (partial ordering)
    double x = NAN, y = 1.0;
    std::cout << "[double] ";
    if (auto r = x <=> y; r == std::partial_ordering::unordered)
        std::cout << "x and y are unordered (NaN involved)\n";
    else if (r < 0) std::cout << "x < y\n";
    else if (r > 0) std::cout << "x > y\n";
    else std::cout << "x == y\n";

    return 0;
}

```

### Template syntax for lambdas
Use familiar template syntax in lambda expressions.
```c++
auto f = []<typename T>(std::vector<T> v) {
  // ...
};
```

### Range-based for loop with initializer
This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem.
```c++
for (auto v = std::vector{1, 2, 3}; auto& e : v) {
  std::cout << e;
}
// prints "123"
```

### [\[likely]] and [\[unlikely]] attributes
These attributes give hints to the compiler but do not guarantee behavior. They can potentially improve performance by organizing code to reduce CPU branch mispredictions.
```c++
sif (condition) [[likely]] {
    // More likely branch
} else [[unlikely]] {
    // Less likely branch
}

```

```c++
#include <iostream>

void process(int value) {
    if (value == 0) [[unlikely]] {
        std::cout << "Rare case: value is zero\n";
    } else [[likely]] {
        std::cout << "Common case: value is non-zero\n";
    }
}
/*
When value == 0, the code in the [[unlikely]] block executes.
For all other values, the [[likely]] branch is expected to be taken.
Helps CPU prefetch the correct instructions more often if used properly.*/
```


### Deprecate implicit capture of this
> In C++20, it's deprecated (not recommended) to use [=] to capture this implicitly in lambdas.

**❌ Problem Example (Deprecated):**
```c++
auto lambda = [=]() {
    std::cout << x;  // uses `this` implicitly
};
/*
- [=] means "capture everything by copy"
- But it also captures this silently, which can cause bugs (like accessing a deleted object)
*/
```
**✅ Safer Ways:**
1. Explicitly capture this:
```c++
auto lambda = [this]() {
    std::cout << x;
};
```
2. Capture a copy of the object (safer if used later):

```c++
auto lambda = [*this]() {
    std::cout << x;
};
```

**🔁 Summary of Capture Modes for this:**
Capture | Captures this? | Copy or Reference? | Safe if object is destroyed?
--------|----------------|--------------------|-----------------------------
[=] (deprecated) | Yes (implicitly) | Reference (pointer) | ❌ No
[this] | Yes (explicitly) | Reference (pointer) | ❌ No
[*this] | Yes (by copy) | Copy of object | ✅ Yes (safe)

### Class types in non-type template parameters
**What is a Non-Type Template Parameter?**
In templates, non-type parameters are values, not types.
Example:
```c++
template<int N>
struct Array {
    int data[N];  // N is a value
};
```
Before C++20, only basic types like int, char, bool, or pointers could be used.

**What's New in C++20?**
> You can now use class types (like std::string_view, std::chrono::duration, user-defined struct, etc.) as non-type template parameters — as long as they are constexpr.
> 

```c++
#include <iostream>
#include <string_view>

template<std::string_view msg>
struct Logger {
    void log() const {
        std::cout << msg << "\n";
    }
};

int main() {
    Logger<"Hello from template!"> logger;
    logger.log();
}

```
### constexpr virtual functions
Before C++20, virtual functions couldn’t be constexpr because virtual dispatch requires runtime info, but constexpr means evaluation at compile-time.

C++20 allows constexpr virtual functions, meaning:
You can call virtual functions at compile-time if the call is on an object whose exact type is known at compile-time.

Enables more flexible constexpr polymorphism.

**✅ Key points:**
- The virtual function must be defined as constexpr.
- You can override virtual functions with constexpr.
- Compile-time calls happen if the dynamic type is known at compile time.
- Otherwise, virtual calls behave normally at runtime.

```c++
#include <iostream>

struct Base {
    virtual constexpr int getValue() const { return 1; }
    virtual ~Base() = default;
};

struct Derived : Base {
    constexpr int getValue() const override { return 42; }
};

int main() {
    constexpr Derived d;
    constexpr int val = d.getValue();  // OK: known type at compile-time
    std::cout << val << "\n";          // Outputs: 42

    Base* b = new Derived();
    std::cout << b->getValue() << "\n"; // Runtime call: Outputs 42

    delete b;
}
```
**Summary:**
Feature | Pre-C++20 | C++20
--------|-----------|------
constexpr virtual | ❌ | ✅ Allowed
Compile-time call | ❌ | ✅ If exact type known

### explicit(bool)
Before C++20, constructors could be either:
-  explicit (prevent implicit conversions), or
- non-explicit (allow implicit conversions).

Example before C++20:

```c++
struct A {
    explicit A(int x) { }
};

A a1 = 10;    // Error: can't implicitly convert int to A because constructor is explicit
A a2(10);     // O

```
**copy initialization.**
> ```c++
> A a1 = 10;
> ```
> This is called copy initialization. The compiler tries to convert the value 10 to type A implicitly by calling a constructor of A that can take an int.
**if constructor is explicit then explicit prevents the constructor from being used implicitly during copy initialization.**

**✅ What C++20 introduced:**
You can now write:
```c++
explicit(condition)
```

where condition is a compile-time boolean that controls whether the constructor is explicit or not.

**📌 Simple Example:**
```c++
#include <iostream>
#include <type_traits>

struct Number {
    int value;
    
    // Constructor is explicit **only if** T is integral (int, char, etc.)
    template<typename T>
    explicit(std::is_integral_v<T>)
    Number(T v) : value(v) {
        std::cout << "Constructor called with value: " << value
                  << (std::is_integral_v<T> ? " (explicit)\n" : " (implicit)\n");
    }
};

void printNumber(Number n) {
    std::cout << "Got a Number with value " << n.value << std::endl;
}

int main() {
    printNumber(3.14);     // double → implicit allowed, constructor called implicitly
    // printNumber(10);    // int → explicit constructor, so error if uncommented
    printNumber(Number(10)); // OK: explicit conversion by direct construction
    
    return 0;
}
/*
Constructor called with value: 3 (implicit)
Got a Number with value 3
Constructor called with value: 10 (explicit)
Got a Number with value 10
*/
```
### Immediate functions
**What is an immediate function (consteval)?**
- A function declared with consteval must be evaluated at compile time.
- You cannot call it at runtime; it only works in compile-time contexts.
- Use it when you want to guarantee the function runs during compilation (e.g., for generating constant values, checking conditions early, or metaprogramming).

**How is it different from constexpr?**
- constexpr functions can run at compile time or runtime.
- consteval functions must run at compile time only

```c++
#include <iostream>
consteval int square(int x) {
    return x * x;
}

int main() {
    constexpr int val = square(5);  // OK: compile-time evaluation
    std::cout << val << "\n";

    // int runtime_val = 10;
    // int result = square(runtime_val); // ERROR: cannot call consteval function with runtime value
    
    return 0;
}

```
### using enum
Bring an enum's members into scope to improve readability. Before:
```c++
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```
After:
```c++
enum class rgba_color_channel { red, green, blue, alpha };

std::string_view to_string(rgba_color_channel my_channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```

### Lambda capture of parameter pack
In C++20, you can directly capture a parameter pack in a lambda capture list using the syntax [...args], which wasn't allowed before C++20.

**Example**
```c++
#include <iostream>

template<typename... Args>
void printAll(Args... args) {
    // Capture all args by value in the lambda capture pack
    auto printer = [args...]() {
        // Using fold expression to print each argument
        ((std::cout << args << " "), ...);
        std::cout << "\n";
    };

/*
void printAll(Args&... args) {
    // Capture all args by reference
    auto printer = [&args...]() {
        ((std::cout << args << " "), ...);
        std::cout << "\n";
    };
    printer();
}
*/
int main() {
    printAll(1, 2, 3, 4, 5);
    printAll("hello", "world", 123);
}

```

### char8_t
Provides a standard type for representing UTF-8 strings.
```c++
char8_t utf8_str[] = u8"\u0123";
```

### constinit
The `constinit` specifier requires that a variable must be initialized at compile-time.
```c++
const char* g() { return "dynamic initialization"; }
constexpr const char* f(bool p) { return p ? "constant initializer" : g(); }

constinit const char* c = f(true); // OK
constinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.
```

### __VA\_OPT\_\_
Helps support variadic macros by evaluating to the given argument if the variadic macro is non-empty.

```c++
#include <iostream>

#define COUNT_ARGS(...) (sizeof((int[]){0 __VA_OPT__(, __VA_ARGS__)})/sizeof(int) - 1)

int main() {
    std::cout << COUNT_ARGS() << "\n";           // prints 0 (no arguments)
    std::cout << COUNT_ARGS(10) << "\n";         // prints 1
    std::cout << COUNT_ARGS(1, 2, 3, 4) << "\n"; // prints 4
}

```

## C++20 Library Features

### Concepts library
Concepts are also provided by the standard library for building more complicated concepts. Some of these include:

**Core language concepts:**
- `same_as` - specifies two types are the same.
- `derived_from` - specifies that a type is derived from another type.
- `convertible_to` - specifies that a type is implicitly convertible to another type.
- `common_with` - specifies that two types share a common type.
- `integral` - specifies that a type is an integral type.
- `default_constructible` - specifies that an object of a type can be default-constructed.

 **Comparison concepts:**
- `boolean` - specifies that a type can be used in Boolean contexts.
- `equality_comparable` - specifies that `operator==` is an equivalence relation.

 **Object concepts:**
- `movable` - specifies that an object of a type can be moved and swapped.
- `copyable` - specifies that an object of a type can be copied, moved, and swapped.
- `semiregular` - specifies that an object of a type can be copied, moved, swapped, and default constructed.
- `regular` - specifies that a type is _regular_, that is, it is both `semiregular` and `equality_comparable`.

 **Callable concepts:**
- `invocable` - specifies that a callable type can be invoked with a given set of argument types.
- `predicate` - specifies that a callable type is a Boolean predicate.

See also: [concepts](#concepts).

### Formatting library
Combine the simplicity of `printf` with the type-safety of `iostream`. Uses braces as placeholders, and supports custom formatting similar to printf-style specifiers.
```c++
std::format("{1} {0}", "world", "hello"); // == "hello world"

int x = 123;
std::string str = std::format("x: {}", x); // str == "x: 123"

// Format to an output iterator:
for (auto x : {1, 2, 3}) {
  std::format_to(std::ostream_iterator<char>{std::cout, "\n"}, "{}", x);
}
```

To format custom types:
```c++
#include <format>
#include <iostream>
#include <string>

// Custom type
struct Point {
    int x, y;
};

// Custom formatter for Point
template <>
struct std::formatter<Point> {
    constexpr auto parse(std::format_parse_context& ctx) {
        return ctx.begin(); // No custom format options
    }

    auto format(const Point& p, std::format_context& ctx) {
        return std::format_to(ctx.out(), "Point({}, {})", p.x, p.y);
    }
};

int main() {
    std::string name = "Alice";
    int age = 30;
    double pi = 3.14159;
    int number = 42;
    Point pt{10, 20};

    // Using std::format with various formatting options
    std::string output = std::format(
        "Name (left aligned): {:<10}\n"
        "Age (zero-padded): {:02}\n"
        "Pi (2 decimal places): {:.2f}\n"
        "Hex: {:#x}, Binary: {:#b}\n"
        "Custom Type: {}\n",
        name,        // {:<10} left-align in width 10
        age,         // {:02} pad with 0 to width 2
        pi,          // {:.2f} 2 decimal precision
        number,      // Hex and binary with prefix
        pt           // Custom type formatting
    );

    std::cout << output;

    return 0;
}

```

### Synchronized buffered outputstream
Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output).
```c++
std::osyncstream{std::cout} << "The value of x is:" << x << std::endl;
```

### std::span
std::span is a lightweight, non-owning view over a contiguous sequence of elements (like arrays, std::vector, std::array). It allows you to pass arrays or parts of containers safely without copying data.
```c++
#include <iostream>
#include <span>
#include <vector>
#include <array>

void print(std::span<int> data) {
    for (int val : data) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    std::vector<int> vec = {10, 20, 30, 40};
    std::array<int, 3> stdarr = {7, 8, 9};

    std::cout << "Array: ";
    print(arr);  // span from C-style array

    std::cout << "Vector: ";
    print(vec);  // span from vector

    std::cout << "std::array: ";
    print(stdarr);  // span from std::array

    // Create a subspan (view of part of the data)
    std::cout << "Subspan of vector (first 2 elements): ";
    print(std::span<int>(vec).subspan(0, 2)); // span over part of vector

    return 0;
}

```

### Bit operations
C++20 provides a new `<bit>` header which provides some bit operations including popcount.
```c++
#include <iostream>
#include <bit>     // C++20
#include <bitset>  // For binary display
#include <cstdint> // For fixed-width integer types

void print(const std::string& label, uint32_t value) {
    std::cout << label << ": " << std::bitset<8>(value) << " (" << value << ")\n";
}

int main() {
    uint32_t x = 0b00011010; // 26 in decimal

    print("Original      ", x);

    // Bit rotation
    print("rotl(x, 2)    ", std::rotl(x, 2));   // Rotate left by 2 bits
    print("rotr(x, 2)    ", std::rotr(x, 2));   // Rotate right by 2 bits

    // Bit counting
    std::cout << "countl_zero  : " << std::countl_zero(x) << '\n';
    std::cout << "countl_one   : " << std::countl_one(x) << '\n';
    std::cout << "countr_zero  : " << std::countr_zero(x) << '\n';
    std::cout << "countr_one   : " << std::countr_one(x) << '\n';
    std::cout << "popcount     : " << std::popcount(x) << " (number of 1s)\n";

    // Bit utility functions
    uint32_t y = 70;
    std::cout << "\nFor value y = " << y << ":\n";
    std::cout << "bit_ceil     : " << std::bit_ceil(y) << " (next power of 2)\n";
    std::cout << "bit_floor    : " << std::bit_floor(y) << " (previous power of 2)\n";
    std::cout << "bit_width    : " << std::bit_width(y) << " (min bits to represent)\n";

    return 0;
}
/*
Original      : 00011010 (26)
rotl(x, 2)    : 01101000 (104)
rotr(x, 2)    : 10000110 (134)
countl_zero  : 3
countl_one   : 0
countr_zero  : 1
countr_one   : 0
popcount     : 4 (number of 1s)

For value y = 70:
bit_ceil     : 128 (next power of 2)
bit_floor    : 64 (previous power of 2)
bit_width    : 7 (min bits to represent)
*/
```

### Math constants
Mathematical constants including PI, Euler's number, etc. defined in the `<numbers>` header.
```c++
std::numbers::pi; // 3.14159...
std::numbers::e; // 2.71828...
```

### std::is_constant_evaluated
std::is_constant_evaluated() is a C++20 feature that tells you at runtime whether the current code is being evaluated at compile time (constexpr) or runtime.

📌 Useful when writing functions that behave differently depending on whether they are used in a constexpr context.


```c++
#include <iostream>
#include <type_traits> // std::is_constant_evaluated()

constexpr int compute() {
    if (std::is_constant_evaluated()) {
        return 42; // Used at compile time
    } else {
        return -1; // Used at runtime
    }
}

int main() {
    // Case 1: constexpr usage (evaluated at compile time)
    constexpr int a = compute(); 
    std::cout << "Compile-time result: " << a << "\n";

    // Case 2: runtime usage
    int b = compute(); 
    std::cout << "Runtime result: " << b << "\n";

    return 0;
}
/*
Compile-time result: 42
Runtime result: -1
*/
```

### std::make_shared supports arrays
```c++
auto p = std::make_shared<int[]>(5); // pointer to `int[5]`
// OR
auto p = std::make_shared<int[5]>(); // pointer to `int[5]`
```

### starts_with and ends_with on strings
Strings (and string views) now have the `starts_with` and `ends_with` member functions to check if a string starts or ends with the given string.
```c++
std::string str = "foobar";
str.starts_with("foo"); // true
str.ends_with("baz"); // false
```

### Check if associative container has element
Associative containers such as sets and maps have a `contains` member function, which can be used instead of the "find and check end of iterator" idiom.
```c++
std::map<int, char> map {{1, 'a'}, {2, 'b'}};
map.contains(2); // true
map.contains(123); // false

std::set<int> set {1, 2, 3};
set.contains(2); // true
```

### std::bit_cast
A safer way to reinterpret an object from one type to another.
```c++
#include <iostream>
#include <bit>
#include <bitset>
#include <cstdint>

// Define a simple color struct
struct Color {
    uint8_t r, g, b, a;
};

static_assert(std::is_trivially_copyable_v<Color>, "Color must be trivially copyable");
static_assert(sizeof(Color) == 4, "Color must be 4 bytes");

void print_bits(const std::string& label, uint32_t bits) {
    std::cout << label << ": 0x" << std::hex << bits << " (" << std::bitset<32>(bits) << ")" << std::dec << "\n";
}

int main() {
    // ========================================
    // 1. Float to uint32_t using bit_cast
    // ========================================
    float pi = 3.14f;
    uint32_t floatBits = std::bit_cast<uint32_t>(pi);
    std::cout << "1️⃣  Float → Bits:\n";
    std::cout << "Float: " << pi << "\n";
    print_bits("Bits ", floatBits);
    std::cout << "\n";

    // ========================================
    // 2. uint32_t to float using bit_cast
    // ========================================
    uint32_t piRaw = 0x4048F5C3;  // Bit pattern for 3.14f
    float piRecovered = std::bit_cast<float>(piRaw);
    std::cout << "2️⃣  Bits → Float:\n";
    print_bits("Raw bits", piRaw);
    std::cout << "Recovered float: " << piRecovered << "\n\n";

    // ========================================
    // 3. Struct to uint32_t (pack color)
    // ========================================
    Color color = {255, 128, 64, 32};
    uint32_t packedColor = std::bit_cast<uint32_t>(color);
    std::cout << "3️⃣  Struct → Packed Bits:\n";
    std::cout << "Color RGBA = (" << (int)color.r << ", " << (int)color.g << ", "
              << (int)color.b << ", " << (int)color.a << ")\n";
    print_bits("Packed color", packedColor);
    std::cout << "\n";

    // ========================================
    // 4. uint32_t to Struct (unpack color)
    // ========================================
    uint32_t rawColor = 0x204080FF;
    Color unpackedColor = std::bit_cast<Color>(rawColor);
    std::cout << "4️⃣  Bits → Struct:\n";
    print_bits("Raw color bits", rawColor);
    std::cout << "Unpacked RGBA = (" << (int)unpackedColor.r << ", "
              << (int)unpackedColor.g << ", " << (int)unpackedColor.b << ", "
              << (int)unpackedColor.a << ")\n\n";

    // ========================================
    // 5. Constexpr bit_cast
    // ========================================
    constexpr float constVal = 1.0f;
    constexpr uint32_t constBits = std::bit_cast<uint32_t>(constVal);
    static_assert(std::bit_cast<float>(constBits) == 1.0f, "bit_cast failed at compile-time");

    std::cout << "5️⃣  Constexpr Float → Bits:\n";
    std::cout << "Constexpr float: " << constVal << "\n";
    print_bits("Constexpr bits", constBits);

    return 0;
}
/*
1️⃣  Float → Bits:
Float: 3.14
Bits : 0x4048f5c3 (01000000010010001111010111000011)

2️⃣  Bits → Float:
Raw bits: 0x4048f5c3 (01000000010010001111010111000011)
Recovered float: 3.14

3️⃣  Struct → Packed Bits:
Color RGBA = (255, 128, 64, 32)
Packed color: 0x204080ff (00100000010000001000000011111111)

4️⃣  Bits → Struct:
Raw color bits: 0x204080ff (00100000010000001000000011111111)
Unpacked RGBA = (255, 128, 64, 32)

5️⃣  Constexpr Float → Bits:
Constexpr float: 1
Constexpr bits: 0x3f800000 (00111111100000000000000000000000)
*/
```

### std::midpoint
Calculate the midpoint of two integers safely (without overflow).
```c++
std::midpoint(1, 3); // == 2
```

### std::to_array
Converts the given array/"array-like" object to a `std::array`.
```c++
#include <iostream>
#include <array>
#include <string_view>

// A simple struct to demonstrate with to_array
struct Point {
    int x, y;
};

int main() {
    // 1️⃣ Integer initializer list
    auto int_array = std::to_array({10, 20, 30, 40});
    std::cout << "1. Integer array:\n";
    for (int v : int_array) {
        std::cout << v << " ";
    }
    std::cout << "\nSize: " << int_array.size() << "\n\n";

    // 2️⃣ String literal to std::array<char, N>
    auto char_array = std::to_array("Hello");
    std::cout << "2. Char array from string literal:\n";
    for (char c : char_array) {
        std::cout << (c == '\0' ? '\\' : c) << " ";
    }
    std::cout << "\nSize: " << char_array.size() << " (includes null terminator)\n\n";

    // 3️⃣ C-style array to std::array
    constexpr int c_array[] = {1, 2, 3, 4, 5};
    auto std_array = std::to_array(c_array); // Automatically deduces size and type
    std::cout << "3. Converted from C-style array:\n";
    for (int v : std_array) {
        std::cout << v << " ";
    }
    std::cout << "\nSize: " << std_array.size() << "\n\n";

    // 4️⃣ Custom struct array
    auto point_array = std::to_array({Point{1, 2}, Point{3, 4}});
    std::cout << "4. Struct array (Points):\n";
    for (const auto& p : point_array) {
        std::cout << "(" << p.x << ", " << p.y << ") ";
    }
    std::cout << "\nSize: " << point_array.size() << "\n";

    return 0;
}
/*
1. Integer array:
10 20 30 40 
Size: 4

2. Char array from string literal:
H e l l o \ 
Size: 6 (includes null terminator)

3. Converted from C-style array:
1 2 3 4 5 
Size: 5

4. Struct array (Points):
(1, 2) (3, 4) 
Size: 2
*/
```

### std::bind_front
Binds the first N arguments (where N is the number of arguments after the given function to `std::bind_front`) to a given free function, lambda, or member function.
```c++
#include <iostream>
#include <functional>

void greet(const std::string& prefix, const std::string& name) {
    std::cout << prefix << " " << name << "!\n";
}

int main() {
    // Bind the first argument ("Hello") permanently
    auto say_hello = std::bind_front(greet, "Hello");

    say_hello("Alice");  // Output: Hello Alice!
    say_hello("Bob");    // Output: Hello Bob!

    return 0;
}
/*
Hello Alice!
Hello Bob!
*/
```

### Uniform container erasure
Provides `std::erase` and/or `std::erase_if` for a variety of STL containers such as string, list, vector, map, etc.

For erasing by value use `std::erase`, or to specify a predicate when to erase elements use `std::erase_if`. Both functions return the number of erased elements.

```c++
std::vector v{0, 1, 0, 2, 0, 3};
std::erase(v, 0); // v == {1, 2, 3}
std::erase_if(v, [](int n) { return n == 0; }); // v == {1, 2, 3}
```

### Three-way comparison helpers
Helper functions for giving names to comparison results:
```c++
std::is_eq(0 <=> 0); // == true
std::is_lteq(0 <=> 1); // == true
std::is_gt(0 <=> 1); // == false
```

See also: [three-way comparison](#three-way-comparison).

### std::lexicographical_compare_three_way
std::lexicographical_compare_three_way is a C++20 function that compares two sequences (like strings or arrays) element by element, using the spaceship operator (<=>), and returns the result of the comparison.

It's like a 3-way version of std::lexicographical_compare, but returns a strong/weak/partial ordering instead of just true/false.
```c++
#include <iostream>
#include <compare>   // for comparison categories
#include <algorithm> // for std::lexicographical_compare_three_way
#include <string>

int main() {
    std::string a = "apple";
    std::string b = "apricot";

    auto result = std::lexicographical_compare_three_way(
        a.begin(), a.end(),
        b.begin(), b.end()
    );

    if (result < 0)
        std::cout << a << " < " << b << "\n";
    else if (result > 0)
        std::cout << a << " > " << b << "\n";
    else
        std::cout << a << " == " << b << "\n";

    return 0;
}
// apple < apricot
```

See also: [three-way comparison](#three-way-comparison), [three-way comparison helpers](#three-way-comparison-helpers).

## Acknowledgements
* [cppreference](http://en.cppreference.com/w/cpp) - especially useful for finding examples and documentation of new library features.
* [C++ Rvalue References Explained](http://web.archive.org/web/20240324121501/http://thbecker.net/articles/rvalue_references/section_01.html) - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.
* [clang](http://clang.llvm.org/cxx_status.html) and [gcc](https://gcc.gnu.org/projects/cxx-status.html)'s standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers' Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - highly recommended book!
* [Jason Turner's C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - nice collection of C++-related videos.
* [What can I do with a moved-from object?](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [What are some uses of decltype(auto)?](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)
* And many more SO posts I'm forgetting...

## Author
Haresh Panchal

## Content Contributors
See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors

## License
MIT