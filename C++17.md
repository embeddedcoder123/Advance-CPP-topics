# C++17

## Overview

Many of these descriptions and examples are taken from various resources (see [Acknowledgements](https://onlinemarkdown.com/#acknowledgements) section) and summarized in my own words.

C++17 includes the following new language features:

* [template argument deduction for class templates](https://onlinemarkdown.com/#template-argument-deduction-for-class-templates)
* [declaring non-type template parameters with auto](https://onlinemarkdown.com/#declaring-non-type-template-parameters-with-auto)
* [folding expressions](https://onlinemarkdown.com/#folding-expressions)
* [new rules for auto deduction from braced-init-list](https://onlinemarkdown.com/#new-rules-for-auto-deduction-from-braced-init-list)
* [constexpr lambda](https://onlinemarkdown.com/#constexpr-lambda)
* [lambda capture this by value](https://onlinemarkdown.com/#lambda-capture-this-by-value)
* [inline variables](https://onlinemarkdown.com/#inline-variables)
* [nested namespaces](https://onlinemarkdown.com/#nested-namespaces)
* [structured bindings](https://onlinemarkdown.com/#structured-bindings)
* [selection statements with initializer](https://onlinemarkdown.com/#selection-statements-with-initializer)
* [constexpr if](https://onlinemarkdown.com/#constexpr-if)
* [utf-8 character literals](https://onlinemarkdown.com/#utf-8-character-literals)
* [direct-list-initialization of enums](https://onlinemarkdown.com/#direct-list-initialization-of-enums)
* [[[fallthrough]], [[nodiscard]], [[maybe\_unused]] attributes](https://onlinemarkdown.com/#fallthrough-nodiscard-maybe_unused-attributes)
* [\_\_has\_include](https://onlinemarkdown.com/#__has_include)
* [class template argument deduction](https://onlinemarkdown.com/#class-template-argument-deduction)

C++17 includes the following new library features:

* [std::variant](https://onlinemarkdown.com/#stdvariant)
* [std::optional](https://onlinemarkdown.com/#stdoptional)
* [std::any](https://onlinemarkdown.com/#stdany)
* [std::string\_view](https://onlinemarkdown.com/#stdstring_view)
* [std::invoke](https://onlinemarkdown.com/#stdinvoke)
* [std::apply](https://onlinemarkdown.com/#stdapply)
* [std::filesystem](https://onlinemarkdown.com/#stdfilesystem)
* [std::byte](https://onlinemarkdown.com/#stdbyte)
* [splicing for maps and sets](https://onlinemarkdown.com/#splicing-for-maps-and-sets)
* [parallel algorithms](https://onlinemarkdown.com/#parallel-algorithms)
* [std::sample](https://onlinemarkdown.com/#stdsample)
* [std::clamp](https://onlinemarkdown.com/#stdclamp)
* [std::reduce](https://onlinemarkdown.com/#stdreduce)
* [prefix sum algorithms](https://onlinemarkdown.com/#prefix-sum-algorithms)
* [gcd and lcm](https://onlinemarkdown.com/#gcd-and-lcm)
* [std::not\_fn](https://onlinemarkdown.com/#stdnot_fn)
* [string conversion to/from numbers](https://onlinemarkdown.com/#string-conversion-tofrom-numbers)
* [rounding functions for chrono durations and timepoints](https://onlinemarkdown.com/#rounding-functions-for-chrono-durations-and-timepoints)

## C++17 Language Features

### Template argument deduction for class templates

Automatic template argument deduction much like how it's done for functions, but now including class constructors.

```c++
template <typename T = float>
struct MyContainer {
  T val;
  MyContainer() : val{} {}
  MyContainer(T val) : val{val} {}
  // ...
};
MyContainer c1 {1}; // OK MyContainer<int>
MyContainer c2; // OK MyContainer<float>
```

### Declaring non-type template parameters with auto

#### What is a Non-Type Template Parameter?

A non-type template parameter is a template parameter that represents a value rather than a type. For example:

```c++
template<int N>
void printN() {
    std::cout << N << std::endl;
}
```

**C++17 Feature: auto in Non-Type Template Parameters**
In C++17, you can now write:

```c++
#include <iostream>
template<auto N>
void print() {
    std::cout << "Value: " << N << std::endl;
}
int main() {
    print<42>();          // int
    print<3.14>();        // double
    print<'A'>();         // char
    print<true>();        // bool

    return 0;
}
```

### Folding expressions

A fold expression performs a fold of a template parameter pack over a binary operator.

* An expression of the form `(... op e)` or `(e op ...)`, where `op` is a fold-operator and `e` is an unexpanded parameter pack, are called *unary folds*.
* An expression of the form `(e1 op ... op e2)`, where `op` are fold-operators, is called a *binary fold*. Either `e1` or `e2` is an unexpanded parameter pack, but not both.

```c++
template <typename... Args>
bool logicalAnd(Args... args) {
    // Binary folding.
    return (true && ... && args);
}
bool b = true;
bool& b2 = b;
logicalAnd(b, b2, true); // == true
```

```c++
template <typename... Args>
auto sum(Args... args) {
    // Unary folding.
    return (... + args);
}
sum(1.0, 2.0f, 3); // == 6.0
```

### New rules for auto deduction from braced-init-list

Changes to `auto` deduction when used with the uniform initialization syntax. Previously, `auto x {3};` deduces a `std::initializer_list<int>`, which now deduces to `int`.

```c++
auto x1 {1, 2, 3}; // error: not a single element
auto x2 = {1, 2, 3}; // x2 is std::initializer_list<int>
auto x3 {3}; // x3 is int
auto x4 {3.0}; // x4 is double
```

### constexpr lambda

Compile-time lambdas using `constexpr`.

```c++
auto identity = [](int n) constexpr { return n; };
static_assert(identity(123) == 123);
```

```c++
constexpr auto add = [](int x, int y) {
  auto L = [=] { return x; };
  auto R = [=] { return y; };
  return [=] { return L() + R(); };
};

static_assert(add(1, 2)() == 3);
```

```c++
constexpr int addOne(int n) {
  return [n] { return n + 1; }();
}

static_assert(addOne(1) == 2);
```

### Lambda capture `this` by value

Capturing `this` in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. `*this` (C++17) will now make a copy of the current object, while `this` (C++11) continues to capture by reference.

```c++
struct MyObj {
  int value {123};
  auto getValueCopy() {
    return [*this] { return value; };
  }
  auto getValueRef() {
    return [this] { return value; };
  }
};
MyObj mo;
auto valueCopy = mo.getValueCopy();
auto valueRef = mo.getValueRef();
mo.value = 321;
valueCopy(); // 123
valueRef(); // 321
```

### Inline variables

The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.

```c++
// Disassembly example using compiler explorer.
struct S { int x; };
inline S x1 = S{321}; // mov esi, dword ptr [x1]
                      // x1: .long 321

S x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]
                      // mov dword ptr [rbp - 8], eax
                      // .L_ZZ4mainE2x2: .long 123
```

It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file.

```c++
struct S {
  S() : id{count++} {}
  ~S() { count--; }
  int id;
  static inline int count{0}; // declare and initialize count to 0 within the class
};
```

### Nested namespaces

Using the namespace resolution operator to create nested namespace definitions.

```c++
namespace A {
  namespace B {
    namespace C {
      int i;
    }
  }
}
```

The code above can be written like this:

```c++
namespace A::B::C {
  int i;
}
```

### Structured bindings

**What are structured bindings?**
Instead of accessing elements via .first, .second, or .get<>(), you can declare multiple variables at once that correspond to parts of a compound object.

1. Iterating over a map with structured bindings

```c++
#include <iostream>
#include <map>
int main() {
    std::map<int, std::string> myMap = {
        {1, "one"},
        {2, "two"},
        {3, "three"}
    };

    for (const auto& [key, value] : myMap) {
        std::cout << key << " -> " << value << std::endl;
    }
    return 0;
}

```

2. Structured bindings with std::pair
```c++
#include <iostream>
#include <utility>

int main() {
    std::pair<int, std::string> p = {1, "hello"};

    auto [num, text] = p;  // Unpack pair into num and text

    std::cout << num << " " << text << std::endl;  // Output: 1 hello
}
```

3. Structured bindings with std::tuple

```c++
#include <iostream>
#include <tuple>

int main() {
    std::tuple<int, double, std::string> t = {1, 3.14, "pi"};

    auto [i, d, s] = t;

    std::cout << i << ", " << d << ", " << s << std::endl;  // Output: 1, 3.14, pi
}
```

4. Structured bindings with array

```c++
int arr[3] = {10, 20, 30};
auto [x, y, z] = arr;
```

5. Structured bindings with struct

```c++
struct Point {
    int x;
    int y;
};

Point pt{5, 10};
auto [a, b] = pt;
std::cout << a << ", " << b << std::endl;  // Output: 5, 10
```
### Selection statements with initializer
New versions of the `if` and `switch` statements which simplify common code patterns and help users keep scopes tight.
```c++
{
  std::lock_guard<std::mutex> lk(mx);
  if (v.empty()) v.push_back(val);
}
// vs.
if (std::lock_guard<std::mutex> lk(mx); v.empty()) {
  v.push_back(val);
}
```

```c++
Foo gadget(args);
switch (auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
// vs.
switch (Foo gadget(args); auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
```

### constexpr if

Write code that is instantiated depending on a compile-time condition.

```c++
template <typename T>
constexpr bool isIntegral() {
  if constexpr (std::is_integral<T>::value) {
    return true;
  } else {
    return false;
  }
}
static_assert(isIntegral<int>() == true);
static_assert(isIntegral<char>() == true);
static_assert(isIntegral<double>() == false);
struct S {};
static_assert(isIntegral<S>() == false);
```

### UTF-8 character literals

A character literal that begins with `u8` is a character literal of type `char`. The value of a UTF-8 character literal is equal to its ISO 10646 code point value.
This if some special character

```c++
char x = u8'x';
```

### Direct list initialization of enums

Enums can now be initialized using braced syntax.

```c++
enum byte : unsigned char {};
byte b {0}; // OK
byte c {-1}; // ERROR
byte d = byte{1}; // OK
byte e = byte{256}; // ERROR
```

### [[fallthrough]], [[nodiscard]], [[maybe\_unused]] attributes

C++17 introduces three new attributes: `[[fallthrough]]`, `[[nodiscard]]` and `[[maybe_unused]]`.

* `[[fallthrough]]` indicates that in switch statement to tell the compiler and readers that you're intentionally letting execution fall through from one case to another without a break.

This helps avoid warnings and makes your code clearer.

```c++
switch (n) {
  case 1:
    // ...
    [[fallthrough]];
  case 2:
    // ...
    break;
  case 3:
    // ...
    [[fallthrough]];
  default:
    // ...
}
```

* `[[nodiscard]]` tells the compiler: "If someone calls this function and ignores the return value, give a warning.”
  It's a way to help prevent bugs by making sure important results aren't accidentally ignored..

**Why use it?**
Sometimes, ignoring a return value is dangerous. For example:

* A function returns true or false to tell you if something succeeded.
* You ignore it and assume it worked — bad idea.

```c++
[[nodiscard]] bool do_something() {
  return is_success; // true for success, false for failure
}

do_something(); // warning: ignoring return value of 'bool do_something()',
                // declared with attribute 'nodiscard'
```

```c++
// Only issues a warning when `error_info` is returned by value.
struct [[nodiscard]] error_info {
  // ...
};

error_info do_something() {
  error_info ei;
  // ...
  return ei;
}

do_something(); // warning: ignoring returned value of type 'error_info',
                // declared with attribute 'nodiscard'
```c++

* `[[maybe_unused]]` indicates to the compiler that a variable or parameter might be unused and is intended.

```c++
void my_callback(std::string msg, [[maybe_unused]] bool error) {
  // Don't care if `msg` is an error message, just log it.
  log(msg);
}
```

### \_\_has\_include

` What is \_\_has\_include?
\_\_has\_include is a preprocessor feature in C++17.
It lets you check if a header file exists before including it.

It's super useful when your code might run in different environments or with different libraries.

One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.

```c++
#if __has_include(<header>)
    #include <header>
#endif

```

### Class template argument deduction

*Class template argument deduction* (CTAD) allows the compiler to deduce template arguments from constructor arguments.

```c++
std::vector v{ 1, 2, 3 }; // deduces std::vector<int>

std::mutex mtx;
auto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard<std::mutex>

auto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair<double, double>*
```

For user-defined types, *deduction guides* can be used to guide the compiler how to deduce template arguments if applicable:

```c++
template <typename T>
struct container {
  container(T t) {}

  template <typename Iter>
  container(Iter beg, Iter end);
};

// deduction guide
template <typename Iter>
container(Iter b, Iter e) -> container<typename std::iterator_traits<Iter>::value_type>;

container a{ 7 }; // OK: deduces container<int>

std::vector<double> v{ 1.0, 2.0, 3.0 };
auto b = container{ v.begin(), v.end() }; // OK: deduces container<double>

container c{ 5, 6 }; // ERROR: std::iterator_traits<int>::value_type is not a type
```

## C++17 Library Features

### std::variant

* std::variant : is a type-safe union that can hold a value from a fixed set of
  types.
* It's part of the  header and is useful when a variable might
  hold different types at different times, similar to a tagged union or a
  discriminated union.

**Why use std::variant?** :

* Type safety: Unlike traditional unions, std::variant
* ensures that only one of the specified types is held, and type checking is
  enforced at compile time.

Alternatives: Replaces unsafe union or complex class hierarchies when
polymorphism isn’t necessary.

```c++
#include <iostream>
#include <string>
#include <variant>

int main() {
    std::variant<int, float, std::string> v;
    v = 42;  // holds int
    std::cout << std::get<int>(v) << "\n";

    v = 3.14f;  // holds float
    std::cout << std::get<float>(v) << "\n";

    v = "hello";  // holds std::string
    std::cout << std::get<std::string>(v) << "\n";

    // Accessing Wrong Type : Accessing the wrong type with std::get throws
    // std::bad_variant_access:
    try {
        std::cout << std::get<int>(
            v);  // if v doesn't hold int now its hold string
    } catch (const std::bad_variant_access& e) {
        std::cerr << "Wrong type access!\n";
    }

    // Checking the Held Type
    if (std::holds_alternative<std::string>(v)) {
        std::cout << "v holds string\n";
    }
    // std::visit applies a visitor (functor or lambda) to the value inside the
    // variant:
    auto visitor = [](auto&& arg) { std::cout << "Value: " << arg << '\n'; };

    std::visit(visitor, v);

    return 0;
}
/*
Program stdout
42
3.14
hello
v holds string
Value: hello
Program stderr
Wrong type access!
*/
```

### std::optional

* std::option : is a utility type that represents a value that may or may not be present — similar to Nullable in other languages.
* It's part of the <optional> header and is useful for returning values from functions that may fail or be undefined, without needing special sentinel values or exceptions.

```c++
#include <iostream>
#include <optional>
#include <string>

std::optional<std::string> getName(bool valid) {
    if (valid) {
        return "Alice";
    } else {
        return std::nullopt;  // indicates no value
    }
}

int main() {
    auto name = getName(false);
    if (name) {
        std::cout << "Name: " << *name << "\n";
    } else {
        std::cout << "No name available\n";
    }

    // Accessing

    std::optional<int> x;
    try {
        std::cout << x.value();
    } catch (std::bad_optional_access) {
        std::cerr << "x is not initiated\n";
    }
    std::optional<std::string> str("Yeh dil mange more!");

    std::cout << "first method: " << *str << "\nsecond Methods: " << str.value()
              << std::endl;
}
/*
Program stdout
No name available
first method: Yeh dil mange more!
second Methods: Yeh dil mange more!
Program stderr
x is not initiated
*/
```c++

### std::any

* std::anyis a type-safe container for single values of any copyable type.
* It's part of <any> header and allows storing and retrieving a value without knowing its type at compile time, unlike std::variant (which is limited to a known set of types).

| Function | Description |
| --- | --- |
| std::any\_cast(a) | Access value as type T |
| a.has\_value() | Returns true if it contains a value |
| a.reset() | Clears the stored value |
| a.type() | Returns std::type\_info of the contained type |

```
#include <any>
#include <iostream>
#include <string>

int main() {
    std::any a;

    a = 42;
    std::cout << std::any_cast<int>(a) << "\n";

    a = std::string("Hello");
    std::cout << std::any_cast<std::string>(a) << "\n";

    a = 3.14;
    try {
        std::cout << std::any_cast<int>(a);  // wrong type!
    } catch (const std::bad_any_cast& e) {
        std::cerr << "Bad any_cast: " << e.what() << '\n';
    }

    a = 100;
    if (a.type() == typeid(int)) {
        std::cout << "a holds an int: " << std::any_cast<int>(a) << '\n';
    }

    return 0;
}
/*
Program stdout
42
Hello
a holds an int: 100
Program stderr
Bad any_cast: bad any_cast
*/
```

### std::string\_view

* std::string\_view : is a non-owning, lightweight view over a string (i.e. a contiguous sequence of characters).
* It does not allocate memory and is designed for performance when you just need to read from a string without modifying or copying it.
* It's part of <string\_view> header.

```c++
#include <iostream>
#include <string_view>

// Much better than overloading for const char* and const std::string&.
void print(std::string_view sv) { std::cout << "String: " << sv << "\n"; }
int main() {
    std::string str = "Hello, world!";
    print(str);                    // From std::string
    print("Hello, string_view!");  // From C-string

    std::string_view sv = "example text";

    // Length
    std::cout << sv.size() << std::endl;  // 12

    // Access character
    std::cout << sv[0] << std::endl;
    ;  // 'e'

    // Substring
    std::string_view sub = sv.substr(0, 7);  // "example"
    std::cout << "sub: " << sub << " sv: " << sv << std::endl;

    // Prefix/suffix remove
    sv.remove_prefix(2);  // now "ample text"
    std::cout << "sv: " << sv << std::endl;
    sv.remove_suffix(5);  // now "ample"
    std::cout << "sv: " << sv << std::endl;

    std::string_view sv1;  // sv is declared, currently empty
    {
        std::string s =
            "hEllo";  // s is a temporary std::string with dynamic memory
        sv1 = s;      // sv1 now points to the internal buffer of s
    }
    std::cout << "sv1: " << sv1
              << std::endl;  // this is not safe refers to danglisng pointer
}
/*
Program stdout
String: Hello, world!
String: Hello, string_view!
12
e
sub: example sv: example text
sv: ample text
sv: ample
*/
```

### std::invoke

* std::invoke privides a uniform way to call callable objects.
* It's part of the / header and is especially useful for invoking member functions, pointers to members, or callable objects in a consistent and type-safe way.

**The goal of std::invoke is to abstract the details of how to call a callable object.
It handles:**

* Function pointers
* Member function pointers
* Pointers to member data
* Lambdas or function objects (functors)
* Objects or references to objects

#### syntax:

**template <class F, class... Args>
decltype(auto) invoke(F&& f, Args&&... args);**

* F is the callable (function, lambda, member pointer, etc.)
* Args... are the arguments passed to it.
* It returns the result of the invocation, using perfect forwarding.
* Can be constexpr if the underlying callable is constexpr.

```c++
#include <functional> // std::invoke()
#include <iostream>

int regular_function(int a, int b) { return a + b; }

struct MyClass {
    int multiply(int x) { return x * 2; }

    int value = 42;
};

struct Functor {
    int operator()(int x) const { return x + 10; }
};

int main() {
    // --- 1. Regular function ---
    int sum = std::invoke(regular_function, 3, 4);
    std::cout << "Regular function: 3 + 4 = " << sum << '\n';
    // Regular function: 3 + 4 = 7

    // --- 2. Lambda function ---
    auto lambda = [](int a, int b) { return a * b; };
    int product = std::invoke(lambda, 5, 6);
    std::cout << "Lambda: 5 * 6 = " << product << '\n';
    // Lambda: 5 * 6 = 30

    // --- 3. Functor (function object) ---
    Functor func;
    int result = std::invoke(func, 7);
    std::cout << "Functor: 7 + 10 = " << result << '\n';
    // Functor: 7 + 10 = 17

    // --- 4. Member function pointer ---
    MyClass obj;
    int doubled = std::invoke(&MyClass::multiply, obj, 8);
    std::cout << "Member function: 8 * 2 = " << doubled << '\n';
    // Member function: 8 * 2 = 16

    // --- 5. Member function pointer with pointer ---
    MyClass* objPtr = &obj;
    int doubledPtr = std::invoke(&MyClass::multiply, objPtr, 9);
    std::cout << "Member function (via pointer): 9 * 2 = " << doubledPtr
              << '\n';
    // Member function (via pointer): 9 * 2 = 18

    // --- 6. Pointer to member data ---
    int memberValue = std::invoke(&MyClass::value, obj);
    std::cout << "Member data: value = " << memberValue << '\n';
    // Member data: value = 42
    return 0;
}
```

### std::apply

* **std::apply :** allows you to call a callable (like a function, lambda, or function object) with a set of arguments stored in a tuple.
  **Problem It Solves**
* Before std::apply, if you had a std::tuple of arguments, and you wanted to call a function with those arguments, you'd need to manually unpack them using template metaprogramming.
  std::apply simplifies this.
* std::apply takes the callable and unpacks the tuple elements as
  arguments to that callable.

**Syntax**

* std::apply(func, std::make\_tuple(arg1, arg2, arg3));
  as being similar to => func(arg1, arg2, arg3);

```
#include <iostream>
#include <string>
#include <tuple>
#include <utility>  // <= this is for std::apply

int add(int a, int b) { return a + b; }

struct MyClass {
    void print(int x) const {
        std::cout << "MyClass::print called with: " << x << std::endl;
    }
};

int main() {
    // 1️⃣ Using std::apply with a regular function
    auto args1 = std::make_tuple(10, 20);
    int sum = std::apply(add, args1);
    std::cout << "Sum using std::apply with function: " << sum << std::endl;
// Sum using std::apply with function: 30

    // 2️⃣ Using std::apply with a lambda
    auto lambda = [](const std::string& label, int value) {
        std::cout << label << " " << value << std::endl;
    };
    auto args2 = std::make_tuple("Lambda output:", 42);
    std::apply(lambda, args2);
// Lambda output: 42

    // 3️⃣ Using std::apply with a member function
    MyClass obj;
    auto args3 = std::make_tuple(&obj, 99);  // note: object pointer must be first
    std::apply(&MyClass::print, args3);
// MyClass::print called with: 99

    return 0;
}
```

### std::filesystem

std::filesystem Quick Reference
Namespace: std::filesystem
Header: <filesystem>

1. Path Management
    fs::path p("file.txt"); — Represents file/directory paths
    p.filename(), p.extension(), p.parent\_path(), p.replace\_extension(".md")
2. Directory Iteration
    fs::directory\_iterator(dir) — Iterate non-recursively over directory entries
    fs::recursive\_directory\_iterator(dir) — Iterate recursively including
   subdirectories
3. File and Directory Checks
    fs::exists(path) — Check existence
    fs::is\_regular\_file(path) — Check if regular file
    fs::is\_directory(path) — Check if directory
    fs::is\_symlink(path) — Check if symbolic link
4. File Operations
    fs::create\_directory(path) — Create one directory
    fs::create\_directories(path) — Create nested directories
    fs::remove(path) — Remove file or empty directory
    fs::remove\_all(path) — Remove directory and contents recursively
    fs::copy(src, dest) — Copy file or directory
    fs::rename(old, new) — Rename or move file/directory
    fs::file\_size(path) — Get size of file in bytes
5. Error Handling
    Throws std::filesystem::filesystem\_error on failure by default
    Use std::error\_code to avoid exceptions:

   std::error\_code ec;
    fs::remove("file.txt", ec);
    if (ec) { //handle error// }
6. List Current Directory
    for (const auto& entry : fs::directory\_iterator(".")) {
    std::cout << entry.path().filename();
    if (fs::is\_directory(entry)) std::cout << " [DIR]";
    std::cout << '\n';
    }

Here, a big file is copied to a temporary path if there is available space:

```
const auto bigFilePath {"bigFileToCopy"};
if (std::filesystem::exists(bigFilePath)) {
  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};
  std::filesystem::path tmpPath {"/tmp"};
  if (std::filesystem::space(tmpPath).available > bigFileSize) {
    std::filesystem::create_directory(tmpPath.append("example"));
    std::filesystem::copy_file(bigFilePath, tmpPath.append("newFile"));
  }
}
```

### std::byte

**std::byte** :is a strongly typed enumeration (enum class) representing a raw byte of memory, introduced in C++17 in the <cstddef> header.  header.
**Purpose:** Provides a clear, type-safe way to work with raw memory as bytes without character semantics.

**Characteristics:**

* Underlying type: unsigned char
* Size: 1 byte
* No implicit conversion to/from integers or characters.
* Supports only bitwise operations (&, |, ^, ~, <<, >>).

**Usage:**

* Initialize with std::byte b = static\_caststd::byte(0x1F);
* Convert to integer with std::to\_integer(b)

**Use cases:** Safe manipulation of raw memory, binary protocols, serialization,
cryptography, etc.

```c++
std::byte a {0};
std::byte b {0xFF};
int i = std::to_integer<int>(b); // 0xFF
std::byte c = a & b;
int j = std::to_integer<int>(c); // 0
```

Note that `std::byte` is simply an enum, and braced initialization of enums become possible thanks to [direct-list-initialization of enums](https://onlinemarkdown.com/#direct-list-initialization-of-enums).

### Splicing for maps and sets

**What is splicing in this context?**
Splicing means moving elements from one container to another, typically from one std::map or std::set to another of the same type,by "extracting" nodes and then "inserting" them in the target container.
This avoids the overhead of copying or moving the keys and values themselves
 since the underlying node is transferred.

```c++
#include <iostream>
#include <map>
#include <set>

int main() {
    // --- std::map example ---
    std::map<int, std::string> map1 = {{1, "one"}, {2, "two"}, {3, "three"}};
    std::map<int, std::string> map2 = {{4, "four"}};

    std::cout << "Before splicing maps:\n";
    std::cout << "map1 contains:\n";
    for (const auto& p : map1)
        std::cout << p.first << " => " << p.second << "\n";
    std::cout << "map2 contains:\n";
    for (const auto& p : map2)
        std::cout << p.first << " => " << p.second << "\n";

    // Extract element with key 2 from map1
    auto nh_map = map1.extract(2);
    // Insert node handle into map2
    auto result_map = map2.insert(std::move(nh_map));

    if (result_map.inserted) {
        std::cout << "Moved element key " << result_map.position->first
                  << " to map2\n";
    } else {
        std::cout << "Failed to move element key 2 to map2\n";
    }

    std::cout << "\nAfter splicing maps:\n";
    std::cout << "map1 contains:\n";
    for (const auto& p : map1)
        std::cout << p.first << " => " << p.second << "\n";
    std::cout << "map2 contains:\n";
    for (const auto& p : map2)
        std::cout << p.first << " => " << p.second << "\n";
     /*
Before splicing maps:
map1 contains:
1 => one
2 => two
3 => three
map2 contains:
4 => four
Moved element key 2 to map2

After splicing maps:
map1 contains:
1 => one
3 => three
map2 contains:
2 => two
4 => four
*/
    // --- std::set example ---
    std::set<int> set1 = {1, 2, 3};
    std::set<int> set2 = {4, 5};

    std::cout << "\nBefore splicing sets:\n";
    std::cout << "set1 contains:";
    for (auto x : set1) std::cout << " " << x;
    std::cout << "\nset2 contains:";
    for (auto x : set2) std::cout << " " << x;
    std::cout << std::endl;

    // Extract element '2' from set1
    auto nh_set = set1.extract(2);
    // Insert node handle into set2
    auto result_set = set2.insert(std::move(nh_set));

    if (result_set.inserted) {
        std::cout << "Moved element " << *result_set.position << " to set2\n";
    } else {
        std::cout << "Failed to move element 2 to set2\n";
    }

    std::cout << "\nAfter splicing sets:\n";
    std::cout << "set1 contains:";
    for (auto x : set1) std::cout << " " << x;
    std::cout << "\nset2 contains:";
    for (auto x : set2) std::cout << " " << x;
    std::cout << std::endl;
/*
Before splicing sets:
set1 contains: 1 2 3
set2 contains: 4 5
Moved element 2 to set2

After splicing sets:
set1 contains: 1 3
set2 contains: 2 4 5
*/

    return 0;
}
```

### Parallel algorithms

**Parallel algorithms** : are part of the Standard Library and provide a way to run standard algorithms concurrently on multiple threads or execution units, potentially improving performance on multi-core processors.
**Key Concepts**
Execution Policies: C++17 introduces execution policies to specify how an algorithm should execute:

* std::execution::seq — Sequential execution (default).
* std::execution::par — Parallel execution.
* std::execution::par\_unseq — Parallel and vectorized

Parallel Algorithms Many standard algorithms got overloads accepting an
execution policy as the first argument.
**Important Notes:**

* Thread Safety: The algorithm itself manages threading; you don’t create threads manually.
* Exceptions: If an exception occurs in a parallel algorithm, it may be wrapped inside std::exception\_list.
* Performance: Not all algorithms
* benefit from parallelism : it depends on the workload, data size, and hardware.

Supported Algorithms: Many standard algorithms support execution policies in C++17, including:

1. for\_each
2. transform
3. sort
4. reduce (introduced in C++17, but reduction algorithms are in C++20)
5. find, find\_if
6. copy, copy\_if
7. fill, fill\_n
    And others.

```c++
#include <algorithm>
#include <chrono>
#include <cmath>
#include <execution> //std::exceution
#include <iostream>
#include <numeric>
#include <vector>

// Simulate expensive CPU work
int heavy_compute(int n) {
    double result = 0;
    for (int i = 0; i < 1000; ++i) {
        result += std::sqrt(n + i);
    }
    return static_cast<int>(result);
}

template <typename ExecPolicy>
void run_test(const std::string& label, ExecPolicy policy) {
    const size_t SIZE = 1'000'000;
    std::vector<int> data(SIZE);
    std::iota(data.begin(), data.end(), 1);  // Fill with 1...SIZE

    std::vector<int> results(SIZE);

    auto start = std::chrono::high_resolution_clock::now();

    std::transform(policy, data.begin(), data.end(), results.begin(),
                   [](int n) { return heavy_compute(n); });

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;

    std::cout << "[" << label << "] Time taken: " << elapsed.count()
              << " seconds\n";
}

int main() {
    std::cout << "Testing heavy compute with large dataset:\n\n";

    run_test("Sequential", std::execution::seq);
    run_test("Parallel", std::execution::par);

    return 0;
}
/*
Testing heavy compute with large dataset:
[Sequential] Time taken: 10.7294 seconds
[Parallel] Time taken: 9.24226 seconds
*/
```

### std::sample

**std::sample :** randomly selects n elements from a given input range and writes them to an output iterator using a random number generator.

```c++
#include <algorithm> // std::sample
#include <iostream>
#include <random>
#include <vector>

int main() {
    // Input data
    std::vector<int> data = {10, 20, 30, 40, 50};

    // Vector to store result
    std::vector<int> result = {100, 200, 300};

    // Random number generator
    std::random_device rd;
    std::mt19937 gen(rd());

    // Sample 2 elements from 'data' into 'result'
    std::sample(data.begin(), data.end(),    // input range
                std::back_inserter(result),  // output iterator
                2,                           // number of elements to sample
                gen);                        // random number generator

    // Output the result
    std::cout << "Randomly selected elements: ";
    for (int n : result) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
/*
Randomly selected elements: 100 200 300 20 30
*/
```

### std::clamp

Clamp given value between a lower and upper bound.
**It returns:**

* lo if the value is less than lo
* hi if the value is greater than hi
* otherwise, the value itself

```c++
#include <algorithm>  // std::clamp
#include <iostream>

int main() {
    int value1 = 5;
    int value2 = 15;
    int value3 = 25;

    int low = 10;
    int high = 20;

    std::cout << std::clamp(value1, low, high) << "\n";  // Output: 10
    std::cout << std::clamp(value2, low, high) << "\n";  // Output: 15
    std::cout << std::clamp(value3, low, high) << "\n";  // Output: 20

    return 0;
}

```

### std::reduce

Fold over a given range of elements. Conceptually similar to `std::accumulate`, but `std::reduce` will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.

The default binary operation is std::plus with an initial value of 0.

```c++
const std::array<int, 3> a{ 1, 2, 3 };
std::reduce(std::cbegin(a), std::cend(a)); // == 6
// Using a custom binary op:
std::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies<>{}); // == 6
```

Additionally you can specify transformations for reducers:

```
std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus<>{}, times_ten); // == 60

const std::array<int, 3> b{ 1, 2, 3 };
const auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };

std::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus<>{}, product_times_ten); // == 140
```

### Prefix sum algorithms

Prefix sum algorithms :are commonly used to efficiently compute the cumulative sum of elements in a list or array, which allows for quick range queries and other operations.

**What is a Prefix Sum?**
Given an array A of size n, the prefix sum array P is defined as:
P[0] = A[0]
P[1] = A[0] + A[1]
P[2] = A[0] + A[1] + A[2]
...
P[i] = A[0] + A[1] + ... + A[i]

```c++
#include <iostream>
#include <numeric>  // for std::partial_sum
#include <vector>

int main() {
    std::vector<int> A = {1, 2, 3, 4, 5};  // Input array
    std::vector<int> P(A.size());          // Prefix sum array

    // Compute prefix sum using std::partial_sum from <numeric>
    std::partial_sum(A.begin(), A.end(), P.begin());

    // Print result
    std::cout << "Prefix Sum Array: ";
    for (int x : P) {
        std::cout << x << " ";
    }
    std::cout << "\n";

    // Example range query: sum of A[1] to A[3] (2 + 3 + 4 = 9)
    int l = 1, r = 3;
    int range_sum = P[r] - (l > 0 ? P[l - 1] : 0);
    std::cout << "Sum from index " << l << " to " << r << " is " << range_sum
              << "\n";

    return 0;
}
/*
Prefix Sum Array: 1 3 6 10 15
Sum from index 1 to 3 is 9
*/
```

### GCD and LCM

Greatest common divisor (GCD) and least common multiple (LCM).

```c++
#include <iostream>
#include <numeric>  // For std::gcd and std::lcm

int main() {
    int a = 24, b = 36;

    int gcd = std::gcd(a, b);  // Built-in function for GCD
    int lcm = std::lcm(a, b);  // Built-in function for LCM

    std::cout << "GCD of " << a << " and " << b << " is " << gcd << '\n';
    std::cout << "LCM of " << a << " and " << b << " is " << lcm << '\n';

    return 0;
}
/*
GCD of 24 and 36 is 12
LCM of 24 and 36 is 72
*/
```

### std::not\_fn

**std::not\_fn:** is a utility function introduced in C++17 that takes a callable object (like a function, lambda, or function object) and returns a new function object that returns the logical negation (!) of the result of the original callable.

```c++
#include <algorithm>
#include <functional>  // std::not_fn()
#include <iostream>
#include <vector>

bool is_even(int n) { return n % 2 == 0; }

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Using std::not_fn to find all odd numbers
    auto is_odd = std::not_fn(is_even);

    for (int n : vec) {
        if (is_odd(n)) {
            std::cout << n << " ";
        }
    }

    return 0;
}
/*
1 3 5
*/
```

### String conversion to/from numbers

1. String → Number

* std::from\_chars
* header: <charconv>

Traditional:

* std::stoi, std::stof, etc. (throws exceptions)
* std::stringstream (flexible, slower)

2. Number → String
   * std::to\_string

Traditional:

* Alternative: std::stringstream

```c++
#include <charconv>  // for from_chars
#include <iostream>
#include <sstream>    // for stringstream
#include <stdexcept>  // for stoi
#include <string>

int main() {
    std::string str_num = "12345";
    std::string str_num1 = "FFABCDE";
    int num1, numHex;

    // === Method 1: from_chars (C++17, no exceptions) ===
    auto result = std::from_chars(str_num.data(), str_num.data() + str_num.size(), num1);  // by  default dec
    auto result2 = std::from_chars( str_num1.data(), str_num1.data() + str_num1.size(), numHex, 16);

    if (result.ec == std::errc()) {  //	No error (conversion succeeded)
        std::cout << "[from_chars] Converted string to number: " << num1 << "\n";
    } else {
        std::cout << "[from_chars] Conversion failed.\n";
    }

    if (result2.ec == std::errc()) {  //	No error (conversion succeeded)
        std::cout << "[from_chars] Converted string to number2: " << std::hex
                  << numHex << "\n";
    } else {
        std::cout << "[from_chars] Conversion failed.\n";
    }

    // === Method 2: stoi (throws exceptions) ===
    try {
        int num2 = std::stoi(str_num);
        std::cout << "[stoi] Converted string to number: " << std::dec<< num2
                  << "\n";
    } catch (const std::exception& e) {
        std::cout << "[stoi] Error: " << e.what() << "\n";
    }

    // === Method 3: stringstream ===
    std::stringstream ss(str_num);
    int num3;
    ss >> num3;
    if (!ss.fail()) {
        std::cout << "[stringstream] Converted string to number: " << num3 << "\n";
    } else {
        std::cout << "[stringstream] Conversion failed.\n";
    }

    // === Number to String (to_string) ===
    std::string str1 = std::to_string(num1);
    std::cout << "[to_string] Converted number to string: " << str1 << "\n";

    // === Number to String (stringstream) ===
    std::stringstream ss2;
    ss2 << num1;
    std::string str2 = ss2.str();
    std::cout << "[stringstream] Converted number to string: " << str2 << "\n";

    return 0;
}
/*
[from_chars] Converted string to number: 12345
[from_chars] Converted string to number2: ffabcde
[stoi] Converted string to number: 12345
[stringstream] Converted string to number: 12345
[to_string] Converted number to string: 12345
[stringstream] Converted number to string: 12345
*/

```

### Rounding functions for chrono durations and timepoints

Provides abs, round, ceil, and floor helper functions for `std::chrono::duration` and `std::chrono::time_point`.

```c++
#include <chrono>
#include <ctime>    // for std::localtime
#include <iomanip>  // for put_time
#include <iostream>

int main() {
    using namespace std::chrono;

    // Example with duration
    milliseconds ms(1234);

    seconds floored = floor<seconds>(ms);
    seconds ceiled = ceil<seconds>(ms);
    seconds rounded = round<seconds>(ms);

    std::cout << "Duration rounding (1234ms):\n";
    std::cout << "  floor  : " << floored.count() << "s\n";
    std::cout << "  ceil   : " << ceiled.count() << "s\n";
    std::cout << "  round  : " << rounded.count() << "s\n";

    // Example with time_point
    system_clock::time_point now = system_clock::now();

    auto floor_tp = floor<seconds>(now);
    auto ceil_tp = ceil<seconds>(now);
    auto round_tp = round<seconds>(now);

    std::time_t floor_time = system_clock::to_time_t(floor_tp);
    std::time_t ceil_time = system_clock::to_time_t(ceil_tp);
    std::time_t round_time = system_clock::to_time_t(round_tp);

    std::cout << "\nTime point rounding (system_clock::now()):\n";
    std::cout << "  floor  : "
              << std::put_time(std::localtime(&floor_time), "%F %T") << '\n';
    std::cout << "  ceil   : "
              << std::put_time(std::localtime(&ceil_time), "%F %T") << '\n';
    std::cout << "  round  : "
              << std::put_time(std::localtime(&round_time), "%F %T") << '\n';

    return 0;
}
/*
Duration rounding (1234ms):
  floor  : 1s
  ceil   : 2s
  round  : 1s

Time point rounding (system_clock::now()):
  floor  : 2025-07-07 09:15:47
  ceil   : 2025-07-07 09:15:48
  round  : 2025-07-07 09:15:48*/
```

## Acknowledgements

* [cppreference](http://en.cppreference.com/w/cpp) - especially useful for finding examples and documentation of new library features.
* [C++ Rvalue References Explained](http://web.archive.org/web/20240324121501/http%3A//thbecker.net/articles/rvalue_references/section_01.html) - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.
* [clang](http://clang.llvm.org/cxx_status.html) and [gcc](https://gcc.gnu.org/projects/cxx-status.html)'s standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.
* [Compiler explorer](https://godbolt.org/)
* [Scott Meyers' Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996) - highly recommended book!
* [Jason Turner's C++ Weekly](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw) - nice collection of C++-related videos.
* [What can I do with a moved-from object?](http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object)
* [What are some uses of decltype(auto)?](http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto)
* And many more SO posts I'm forgetting...

## Author

Haresh

## Content Contributors

See: <https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors>

## License

MIT

File: C++17

42,301 characters 5,965 words 210 paragraphs

Privacy and cookie settings

Managed by Google. Complies with IAB TCF. CMP ID: 300

Online Markdown Editor - Simple, Fast & Live Preview | OnlineMarkdown.com